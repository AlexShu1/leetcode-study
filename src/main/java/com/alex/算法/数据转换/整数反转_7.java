package com.alex.算法.数据转换;

/**
 * 描述
 * <p>
 * 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。
 * <p>
 * 如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。
 * <p>
 * 假设环境不允许存储 64 位整数（有符号或无符号）。
 * 示例 1：
 * <p>
 * 输入：x = 123
 * 输出：321
 * 示例 2：
 * <p>
 * 输入：x = -123
 * 输出：-321
 * 示例 3：
 * <p>
 * 输入：x = 120
 * 输出：21
 * 示例 4：
 * <p>
 * 输入：x = 0
 * 输出：0
 * 提示：
 * <p>
 * -231 <= x <= 231 - 1
 *
 * @auth shufei
 * @date 2025/3/1
 */
public class 整数反转_7 {

    public static void main(String[] args) {
        整数反转_7 call = new 整数反转_7();
        int res = call.reverseV2(-214748364);
        System.out.println(res);
    }

    /**
     * 解题思路：
     * 首先我们想一下，怎么去反转一个整数？
     * 用栈？
     * 或者把整数变成字符串，再去反转这个字符串？
     * 这两种方式是可以，但并不好。实际上我们只要能拿到这个整数的 末尾数字 就可以了。
     * 以12345为例，先拿到5，再拿到4，之后是3，2，1，我们按这样的顺序就可以反向拼接处一个数字了，也就能达到 反转 的效果。
     * 怎么拿末尾数字呢？好办，用取模运算就可以了
     * <p>
     * 核心问题: 需要处理好数据边界问题; Integer.MAX_VALUE;
     */
    public int reverseV2(int x) {
        int res = 0;
        while (x != 0) {
            //每次取末尾数字
            int tmp = x % 10;
            //判断是否 大于 最大32位整数
            // why: 只要之前的数字已经大于了214748364; 那么, 后续的数字是无关紧要的; 前面大于了, 后面追加任何数字只会更大.
            // 若等于214748364, 则需要细致的比对最后一位数字的大小.
            if (res > 214748364 || (res == 214748364 && tmp > 7)) {
                return 0;
            }
            //判断是否 小于 最小32位整数
            if (res < -214748364 || (res == -214748364 && tmp < -8)) {
                return 0;
            }
            res = res * 10 + tmp;
            x /= 10;
        }
        return res;

    }
}
